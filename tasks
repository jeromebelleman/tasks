#! /usr/bin/env python

import sys
reload(sys)
sys.setdefaultencoding('UTF8')

import os
import argparse
import datetime, time
import subprocess
import re
import tempfile
import json
import uuid

# TODO Recurring tasks
# TODO Handle simultaneous instances

DATEFMT = '%Y/%m/%d'

REPROPRIO = re.compile(r'''^Project:[ ]+(?P<project>\S+)[ ]+
                            Priority:[ ]*(?P<priority>\S+)?$''',
                       re.VERBOSE)
REDATES   = re.compile(r'''^Opened:[ ]+(?P<opened>\d{4}/\d\d/\d\d)[ ]+
                            Closed:[ ]*(?P<closed>\d{4}/\d\d/\d\d)?$''',
                       re.VERBOSE)
REUUID    = re.compile(r'^UUID:[ ]+(?P<uuid>([0-9A-Fa-f]+-){4}[0-9A-Fa-f]+)$')

def parse(fhl):
    def edit(task):
        task['description'] = task['description'].strip()
        if task['project'] and task['description'] and \
            'TODO' not in (task['project'], task['description']):
            if uuid4:
                tasks[uuid4] = task
            else:
                tasks[str(uuid.uuid4())] = task

    tasks = {}

    description = ''
    infields = True
    for line in fhl:
        if infields:
            if line == '\n':
                continue

            match = REPROPRIO.match(line)
            if match:
                uuid4 = None
                task = {
                        'project':     match.group('project'),
                        'description': '',
                       }
                if match.group('priority'):
                    task['priority'] = match.group('priority')
                continue

            match = REDATES.match(line)
            if match:
                task['opened'] = match.group('opened')
                if match.group('closed'):
                    task['closed'] = match.group('closed')
                continue

            match = REUUID.match(line)
            if match:
                uuid4 = match.group('uuid')
                continue

            if line =='Description:\n':
                infields = False
        else:
            if line == '--\n':
                edit(task)
                infields = True
            else:
                task['description'] += line

    if not infields:
        edit(task)

    return tasks

def ls(args, tasks):
    def prioritykey(task):
        try:
            priority = tasksubset[task]['priority']
            try:
                return float(priority)
            except ValueError:
                due = datetime.datetime.strptime(priority, DATEFMT)
                due = datetime.date(due.year, due.month, due.day)
                return topprio - (due - datetime.date.today()).days
        except TypeError: # When topprio is None
                return -time.mktime(due.timetuple())
        except KeyError:
            return None

    # Load template
    with open(args.shared + '/template') as fhl:
        template = fhl.read()

    # Find top priority
    topprio = None
    for task in tasks:
        try:
            newprio = int(tasks[task]['priority'])
            topprio = newprio if newprio > topprio else topprio
        except (ValueError, KeyError):
            pass

    # Filter by whatever is specified in args
    tasksubset = tasks
    if args.project:
        tasksubset = {task: tasksubset[task] for task in tasksubset
                      if tasksubset[task]['project'] == args.project}
    if not args.closed:
        tasksubset = {task: tasksubset[task] for task in tasksubset
                      if 'closed' not in tasksubset[task]}

    # Write tasks to temporary file
    tmp = tempfile.NamedTemporaryFile(dir=args.directory + '/tmp')
    for task in sorted(tasksubset, key=prioritykey, reverse=True):
        tmp.write(template.format(
            project=tasksubset[task]['project'],
            priority=tasksubset[task]['priority']
                     if 'priority' in tasksubset[task] else '',
            opened=tasksubset[task]['opened'],
            closed=tasksubset[task]['closed']
                   if 'closed' in tasksubset[task] else '',
            uuid=task,
            description=tasksubset[task]['description'],
        ))
        print >> tmp, '\n--\n'
    tmp.flush()

    # Run Vim
    subprocess.call(['vim', '-S', args.shared + '/vimrc', tmp.name])

    # Parse tasks
    with open(tmp.name) as fhl:
        newtasksubset = parse(fhl)

    # Apply changes
    for task in newtasksubset:
        tasks[task] = newtasksubset[task]

    # Remove tasks
    for task in set(tasksubset) - set(newtasksubset):
        del tasks[task]

    # Write tasks to file
    with open(args.directory + '/tasks.json', 'w') as fhl:
        json.dump(tasks, fhl, indent=4)

def add(args, tasks):
    # Load template
    with open(args.shared + '/template') as fhl:
        template = fhl.read()

    # Open temporary file
    tmp = tempfile.NamedTemporaryFile(dir=args.directory + '/tmp')
    tmp.write(template.format(
                              project='TODO',
                              priority='',
                              opened=datetime.date.today().strftime(DATEFMT),
                              closed='',
                              uuid='',
                              description='TODO',
                             ))
    tmp.flush()

    # Run Vim
    subprocess.call(['vim', '-S', args.shared + '/vimrc', tmp.name])

    # Parse tasks
    with open(tmp.name) as fhl:
        tasks = dict(tasks.items() + parse(fhl).items())

    # Write tasks to file
    with open(args.directory + '/tasks.json', 'w') as fhl:
        json.dump(tasks, fhl, indent=4)

def priorities(args, tasks):
    for priority in set([tasks[task]['priority'] for task in tasks
                         if 'priority' in tasks[task]]):
        try:
            print float(priority)
        except ValueError:
            pass

def projects(args, tasks):
    for project in set([tasks[task]['project'] for task in tasks]):
        print project

def main():
    # Arguments
    parser = argparse.ArgumentParser(description="Manage tasks")
    parser.add_argument('-d', '--directory', help="task directory",
                        default='~/.tasks', type=os.path.expanduser)
    parser.add_argument('-s', '--shared', help="shared directory",
                        default='/usr/share/tasks')
    subparser = parser.add_subparsers()

    addparser = subparser.add_parser('add', help="add tasks")
    addparser.set_defaults(func=add)

    lsparser = subparser.add_parser('ls', help="list tasks")
    lsparser.add_argument('-p', '--project')
    lsparser.add_argument('-c', '--closed', help="display closed tasks too",
                          action='store_true')
    lsparser.set_defaults(func=ls)

    projectsparser = subparser.add_parser('projects',
                                          help="list projects (for completion)")
    projectsparser.set_defaults(func=projects)

    priosparser = subparser.add_parser('priorities',
                                       help="list priorities (for completion)")
    priosparser.set_defaults(func=priorities)

    args = parser.parse_args()

    # Make directories
    for dirname in args.directory, args.directory + '/tmp':
        try:
            os.mkdir(dirname)
        except OSError:
            pass

    # Load tasks
    try:
        with open(args.directory + '/tasks.json') as fhl:
            tasks = json.load(fhl)
    except IOError:
        tasks = {}

    # Run
    args.func(args, tasks)

if __name__ == '__main__':
    sys.exit(main())
