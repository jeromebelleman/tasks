#! /usr/bin/env python

import sys
reload(sys)
sys.setdefaultencoding('UTF8')

import os
import argparse
import datetime, time
import subprocess
import re
import tempfile
import json
import uuid

# TODO Recurring tasks
# TODO Git

DATEFMT = '%Y/%m/%d'

REPROPRIO = re.compile(r'''^Project:[ ]+(?P<project>\S+)[ ]+
                            Priority:[ ]*(?P<priority>\S+)?$''',
                       re.VERBOSE)
REDATES   = re.compile(r'''^Opened:[ ]+(?P<opened>\d{4}/\d\d/\d\d)[ ]+
                            Closed:[ ]*(?P<closed>\d{4}/\d\d/\d\d)?$''',
                       re.VERBOSE)
REUUID    = re.compile(r'^UUID:[ ]+(?P<uuid>([0-9A-Fa-f]+-){4}[0-9A-Fa-f]+)$')
RETW      = re.compile(r'(\w+:"[^"]+")')

NOPROJ    = 'noproject'

def commit(directory):
    def commit():
        subprocess.check_call(['git', 'commit', '-qmAutocommit'], cwd=directory)

    def add():
        subprocess.check_call(['git', 'add', 'tasks.json'], cwd=directory)

    try:
        add()
    except subprocess.CalledProcessError:
        subprocess.check_call(['git', 'init', '-q'], cwd=directory)
        add()

    try:
        commit()
    except subprocess.CalledProcessError:
        pass

class RecurringException(Exception):
    pass

def loadtasks(directory):
    try:
        with open(directory + '/tasks.json') as fhl:
            return json.load(fhl)
    except (IOError, ValueError):
        return {}

def dumptasks(directory, tasks):
    with open(directory + '/tasks.json', 'w') as fhl:
        json.dump(tasks, fhl, indent=4)
    commit(directory)

def parse(fhl):
    def edit(task):
        task['description'] = task['description'].strip()
        if task['project'] and task['description'] and \
            'TODO' not in (task['project'], task['description']):
            if uuid4:
                tasks[uuid4] = task
            else:
                tasks[str(uuid.uuid4())] = task

    tasks = {}

    description = ''
    infields = True
    for line in fhl:
        if infields:
            if line == '\n':
                continue

            match = REPROPRIO.match(line)
            if match:
                uuid4 = None
                task = {
                        'project':     match.group('project'),
                        'description': '',
                       }
                if match.group('priority'):
                    task['priority'] = match.group('priority')
                continue

            match = REDATES.match(line)
            if match:
                task['opened'] = match.group('opened')
                if match.group('closed'):
                    task['closed'] = match.group('closed')
                continue

            match = REUUID.match(line)
            if match:
                uuid4 = match.group('uuid')
                continue

            if line =='Description:\n':
                infields = False
        else:
            if line == '--\n':
                edit(task)
                infields = True
            else:
                task['description'] += line

    if not infields:
        edit(task)

    return tasks

def ls(args, tasks):
    def prioritykey(task):
        try:
            priority = tasksubset[task]['priority']
            try:
                return float(priority)
            except ValueError:
                due = datetime.datetime.strptime(priority, DATEFMT)
                due = datetime.date(due.year, due.month, due.day)
                return topprio - (due - datetime.date.today()).days
        except TypeError: # When topprio is None
                return -time.mktime(due.timetuple())
        except KeyError:
            return None

    # Load template
    with open(args.shared + '/template') as fhl:
        template = fhl.read()

    # Find top priority
    topprio = None
    for task in tasks:
        try:
            newprio = int(tasks[task]['priority'])
            topprio = newprio if newprio > topprio else topprio
        except (ValueError, KeyError):
            pass

    # Filter by whatever is specified in args
    tasksubset = tasks
    if args.project:
        tasksubset = {task: tasksubset[task] for task in tasksubset
                      if tasksubset[task]['project'].startswith(args.project)}
    if not args.closed:
        tasksubset = {task: tasksubset[task] for task in tasksubset
                      if 'closed' not in tasksubset[task]}

    # Write tasks to temporary file
    tmp = tempfile.NamedTemporaryFile(dir=args.directory + '/tmp')
    for task in sorted(tasksubset, key=prioritykey, reverse=True):
        tmp.write(template.format(
            project=tasksubset[task]['project'],
            priority=tasksubset[task]['priority']
                     if 'priority' in tasksubset[task] else '',
            opened=tasksubset[task]['opened'],
            closed=tasksubset[task]['closed']
                   if 'closed' in tasksubset[task] else '',
            uuid=task,
            description=tasksubset[task]['description'],
        ))
        print >> tmp, '\n--\n'
    tmp.flush()

    # Run Vim
    subprocess.call(['vim', '-S', args.shared + '/vimrc', tmp.name])

    # Parse tasks
    with open(tmp.name) as fhl:
        newtasksubset = parse(fhl)

    tasks = loadtasks(args.directory)
    # Apply changes
    for task in newtasksubset:
        tasks[task] = newtasksubset[task]
    # Remove tasks
    for task in set(tasksubset) - set(newtasksubset):
        del tasks[task]

    # Write tasks to file
    dumptasks(args.directory, tasks)

def add(args, tasks):
    # Load template
    with open(args.shared + '/template') as fhl:
        template = fhl.read()

    # Open temporary file
    tmp = tempfile.NamedTemporaryFile(dir=args.directory + '/tmp')
    tmp.write(template.format(
                              project='TODO',
                              priority='',
                              opened=datetime.date.today().strftime(DATEFMT),
                              closed='',
                              uuid='',
                              description='TODO',
                             ))
    tmp.flush()

    # Run Vim
    subprocess.call(['vim', '-S', args.shared + '/vimrc', tmp.name])

    # Add new tasks
    tasks = loadtasks(args.directory)
    with open(tmp.name) as fhl:
        tasks = dict(tasks.items() + parse(fhl).items())

    # Write tasks to file
    dumptasks(args.directory, tasks)

def priorities(args, tasks):
    # Find each distinct priority with a sample description
    priorities = {}
    for task in [task for task in tasks if 'closed' not in tasks[task]]:
        if tasks[task]['priority'] not in priorities:
            try:
                priorities[float(tasks[task]['priority'])] = \
                    tasks[task]['description']
            except ValueError:
                pass

    # Report
    for priority in priorities:
        print priority, priorities[priority]

def projects(args, tasks):
    for project in sorted(set([tasks[task]['project'] for task in tasks])):
        print project

def importcb(args, tasks):
    try:
        fhl = open(args.filepath)
    except IOError, exc:
        print >> sys.stderr, exc
        return 1

    tasks = {}
    for line in fhl:
        fields = RETW.split(line)
        task, tags, annotations = {}, None, []
        try:
            # Parse fields
            for field in fields:
                if field in ('[', ']\n', ' '):
                    continue

                key, value = field.split(':', 1)
                if key == 'description':
                    task['description'] = value[1:-1]
                elif key == 'entry':
                    opened = datetime.date.fromtimestamp(float(value[1:-1]))
                    task['opened'] = opened.strftime(DATEFMT)
                elif key == 'end':
                    closed = datetime.date.fromtimestamp(float(value[1:-1]))
                    task['closed'] = closed.strftime(DATEFMT)
                elif key == 'priority' and 'priority' not in task:
                    # Set numeric priority only if no due time
                    priority = value[1:-1]
                    if priority == 'L':
                        task['priority'] = 1
                    elif priority == 'M':
                        task['priority'] = 2
                    elif priority == 'H':
                        task['priority'] = 3
                elif key == 'project':
                    task['project'] = value[1:-1]
                elif key == 'due':
                    priority = datetime.date.fromtimestamp(float(value[1:-1]))
                    task['priority'] = priority.strftime(DATEFMT)
                elif key.startswith('annotation_'):
                    annotations.append(value[1:-1])
                elif key == 'uuid':
                    uuid4 = value[1:-1]
                elif key == 'tags':
                    tags = value[1:-1]
                elif key == 'recur':
                    raise RecurringException
                elif key in ('imask', 'mask', 'parent', 'status',
                             'priority', 'wait', 'start', 'depends',
                             'until'):
                    pass
                else:
                    print >> sys.stderr, "Unexpected field: " + key
                    return 1

            # Build task
            if 'project' not in task:
                task['project'] = NOPROJ

            if tags == 'work':
                task['project'] = 'cern.' + task['project']
            elif not tags:
                task['project'] = 'home.' + task['project']
            else:
                print >> sys.stderr, "Unexpected tags: " + tags
                return 1
            
            task['description'] = \
                '\n\n'.join([task['description']] + annotations)

            # Add task
            tasks[uuid4] = task
        except RecurringException:
            pass

    print json.dumps(tasks, indent=4)
    fhl.close()

def main():
    # Arguments
    parser = argparse.ArgumentParser(description="Manage tasks")
    parser.add_argument('-d', '--directory', help="task directory",
                        default='~/.tasks', type=os.path.expanduser)
    parser.add_argument('-s', '--shared', help="shared directory",
                        default='/usr/share/tasks')
    subparser = parser.add_subparsers()

    addparser = subparser.add_parser('add', help="add tasks")
    addparser.set_defaults(func=add)

    lsparser = subparser.add_parser('ls', help="list tasks")
    lsparser.add_argument('-p', '--project')
    lsparser.add_argument('-c', '--closed', help="display closed tasks too",
                          action='store_true')
    lsparser.set_defaults(func=ls)

    projectsparser = subparser.add_parser('projects',
                                          help="list projects (for completion)")
    projectsparser.set_defaults(func=projects)

    priosparser = subparser.add_parser('priorities',
                                       help="list priorities (for completion)")
    priosparser.set_defaults(func=priorities)

    importparser = subparser.add_parser('import',
                                        help="import from Taskwarrior")
    importparser.add_argument(metavar='file', dest='filepath',
                              type=os.path.expanduser, help="file path")
    importparser.set_defaults(func=importcb)

    args = parser.parse_args()

    # Make directories
    for dirname in args.directory, args.directory + '/tmp':
        try:
            os.mkdir(dirname)
        except OSError:
            pass

    # Load tasks
    tasks = loadtasks(args.directory)

    # Run
    args.func(args, tasks)

if __name__ == '__main__':
    sys.exit(main())
