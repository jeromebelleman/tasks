#! /usr/bin/env python

import sys
reload(sys)
sys.setdefaultencoding('UTF8')

import os
import argparse
import datetime
import subprocess
import re
import tempfile
import json
import uuid

DATEFMT = '%Y/%m/%d'

REPROPRIO = re.compile(r'''^Project:[ ]+(?P<project>\S+)[ ]+
                            Priority:[ ]+(?P<priority>\S+)$''',
                       re.VERBOSE)
REDATES   = re.compile(r'''^Opened:[ ]+(?P<opened>\d{4}/\d\d/\d\d)[ ]+
                            Closed:[ ]+(?P<closed>\d{4}/\d\d/\d\d)?$''',
                       re.VERBOSE)
REUUID    = re.compile(r'^UUID:[ ]+(?P<uuid>([0-9A-Fa-f]+-){4}[0-9A-Fa-f]+)$')

def parse(fhl, tasks):
    def add(task):
        task['description'] = task['description'].strip()
        if task['project'] and task['description'] and \
            'TODO' not in (task['project'], task['description']):
            if uuid4:
                tasks[uuid4] = task
            else:
                tasks[str(uuid.uuid4())] = task

    description = ''
    infields = True
    for line in fhl:
        if infields:
            if line == '\n':
                continue

            match = REPROPRIO.match(line)
            if match:
                uuid4 = None
                task = {
                        'project':     match.group('project'),
                        'priority':    match.group('priority'),
                        'description': '',
                       }
                continue

            match = REDATES.match(line)
            if match:
                task['opened'] = match.group('opened')
                task['closed'] = match.group('closed')
                continue

            match = REUUID.match(line)
            if match:
                uuid4 = match.group('uuid')
                continue

            if line =='Description:\n':
                infields = False
        else:
            if line == '--\n':
                add(task)
                infields = True
            else:
                task['description'] += line

    try:
        add(task)
    except UnboundLocalError:
        pass

def ls(args, tasks):
    # Load template
    with open(args.shared + '/template') as fhl:
        template = fhl.read()

    # Filter by whatever is specified in args
    if args.project:
        tasksubset = {task: tasks[task] for task in tasks
                      if tasks[task]['project'] == args.project}
    else:
        tasksubset = tasks

    # Write tasks to temporary file
    tmp = tempfile.NamedTemporaryFile(dir=args.directory + '/tmp')
    for task in sorted(tasksubset,
                       key=lambda task: tasksubset[task]['priority'],
                       reverse=True):
        tmp.write(template.format(
            project=tasksubset[task]['project'],
            priority=tasksubset[task]['priority'],
            opened=tasksubset[task]['opened'],
            closed=tasksubset[task]['closed'] if 'closed' in task else '',
            uuid=task,
            description=tasksubset[task]['description'],
        ))
        print >> tmp, '\n--\n'
    tmp.flush()

    # Run Vim
    subprocess.call(['vim', '-S', args.shared + '/vimrc', tmp.name])

    # Parse tasks
    with open(tmp.name) as fhl:
        parse(fhl, tasksubset)

    # Apply changes
    for task in tasksubset:
        tasks[task] = tasksubset[task]

    # Write tasks to file
    with open(args.directory + '/tasks.json', 'w') as fhl:
        json.dump(tasks, fhl, indent=4)

def add(args, tasks):
    # Load template
    with open(args.shared + '/template') as fhl:
        template = fhl.read()

    # Open temporary file
    tmp = tempfile.NamedTemporaryFile(dir=args.directory + '/tmp')
    tmp.write(template.format(
                              project='TODO',
                              priority='TODO',
                              opened=datetime.date.today().strftime(DATEFMT),
                              closed='',
                              uuid='',
                              description='TODO',
                             ))
    tmp.flush()

    # Run Vim
    subprocess.call(['vim', '-S', args.shared + '/vimrc', tmp.name])

    # Parse tasks
    with open(tmp.name) as fhl:
        parse(fhl, tasks)

    # Write tasks to file
    with open(args.directory + '/tasks.json', 'w') as fhl:
        json.dump(tasks, fhl, indent=4)

def main():
    # Arguments
    parser = argparse.ArgumentParser(description="Manage tasks")
    parser.add_argument('-d', '--directory', help="task directory",
                        default='~/.tasks', type=os.path.expanduser)
    parser.add_argument('-s', '--shared', help="shared directory",
                        default='/usr/share/tasks')
    subparser = parser.add_subparsers()


    addparser = subparser.add_parser('add', help="add tasks")
    addparser.set_defaults(func=add)

    lsparser = subparser.add_parser('ls', help="list tasks")
    lsparser.add_argument('-p', '--project')
    lsparser.set_defaults(func=ls)

    args = parser.parse_args()

    # Make directories
    for dirname in args.directory, args.directory + '/tmp':
        try:
            os.mkdir(dirname)
        except OSError:
            pass

    # Load tasks
    try:
        with open(args.directory + '/tasks.json') as fhl:
            tasks = json.load(fhl)
    except IOError:
        tasks = {}

    # Run
    args.func(args, tasks)

if __name__ == '__main__':
    sys.exit(main())
